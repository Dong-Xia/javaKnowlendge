# mysql隔离级别
## 数据库四大特性
- 原子性：要么成功要么失败，最小分割单位，不能进行更细粒度的拆分
- 隔离性：每个事务之间执行互不影响
- 一致性：针对一个事务操作提交前和提交后的状态一致，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的，致力于数据的可见性
- 持久性：一旦事务执行成功，数据将存放起来，不会丢失
## 数据库隔离级别
- 未提交读：数据库并发能力最强。可以读取到事务未提交前的数据，可能引发脏读。
- 提交读：只能读取事务提交后的数据，会引发不可重复读问题。oracle采用的机制。
- 重复读：**该sql第一次读取到数据后，就将这些数据加锁（悲观锁），
其它事务无法修改这些数据，就可以实现可重复读了。
但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，
或者修改了全部数据，事务B还是可以insert数据提交，
这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，
不能通过行锁来避免**。需要Serializable隔离级别 ，读用读锁，写用写锁，
读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，
但会极大的降低数据库的并发能力。mysql的innodb引擎采用该机制
- 串行：数据库的并发能力最差，只能允许一个事务执行，不论是读还是写。

## 数据库的一致性理解
　　一致性是指数据处于一种语义上的有意义且正确的状态。一致性是对数据可见性的约束，保证在一个事务中的多次操作的数据中间状态对其他事务不可见的。因为这些中间状态，是一个过渡状态，与事务的开始状态和事务的结束状态是不一致的。
举个栗子，张三给李四转账100元。事务要做的是从张三账户上减掉100元，李四账户上加上100元。一致性的含义是其他事务要么看到张三还没有给李四转账的状态，要么张三已经成功转账给李四的状态，而对于张三少了100元，李四还没加上100元这个中间状态是不可见的。
那么反驳的声音来了：

    1.要么转账操作全部成功，要么全部失败，这是原子性。从例子上看全部成功，那么一致性就是原子性的一部分咯，为什么还要单独说一致性和原子性？
    2.你说的不对。在未提交读的隔离级别下是事务内部操作是可见的，这时候会出现脏读，明显违背了一致性，怎么解释？

好吧，你的疑问很有道理，也很充分，这正说明你对事务的ACID特性理解的很到位。不过，需要注意的是：

    1.原子性和一致性的的侧重点不同：原子性关注状态，要么全部成功，要么全部失败，不存在部分成功的状态。
    而一致性关注数据的可见性，中间状态的数据对外部不可见，只有最初状态和最终状态的数据对外可见。
    
    2.在未提交读的隔离级别下，会造成脏读，这就是因为一个事务读到了另一个事务操作内部的数据。
    ACID中是的一致性描述的是一个最理想的事务应该怎样的，是一个强一致性状态，如果要做到这点，
    需要使用排它锁把事务排成一队，即Serializable串行的隔离级别，这样性能就大大降低了。现实是骨感的，
    所以使用隔离性的不同隔离级别会破坏数据一致性，导致数据的中间过程也会被可见，但是却获取了更好的性能。

