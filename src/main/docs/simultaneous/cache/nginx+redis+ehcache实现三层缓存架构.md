# 上亿流量电商网站采用nginx+redis+ehcache实现三层缓存架构
<!-- MarkdownTOC -->
- [1. 采用三层架构的理由](#1-采用三层架构的理由)
- [2. 三层架构每一层的意义](#2-三层架构每一层的意义)
    - [2.1 三层缓存架构读取数据顺序](#21-三层缓存架构读取数据顺序)
- [3.关于更新缓存的两种情形说明](#3-关于缓存更新的两种情形说明)
    - [3.1 时效性高数据:数据库和redis缓存双写策略](#31-时效性高数据:数据库和redis缓存双写策略)
    - [3.2 时效性低数据:消息队列MQ异步通知方案](#32-时效性低数据:消息队列MQ异步通知方案)
<!-- /MarkdownTOC -->
## 1. 采用三层架构的理由
　　很多人以为，做个缓存，非常简单，就是在项目中用一下redis，更深一点，就是采用redis cluster集群，其实这样的缓存架构是远远不够的；
在当今电商等网站访问量和数据量井喷的今天，需要设计出支撑电商复杂的场景下的高并发的缓存，其中遇到的问题是非常非常之多，绝对不是说简单的使用一下redis就可以了。

　　因此面对复杂高并发的缓存，采用三级缓存：nginx本地缓存+redis分布式缓存+tomcat堆缓存的多级缓存架构，其结构如图：

![电商网站三层缓存架构](/src/main/images/redis/电商网站三层缓存架构.png)

## 2. 三层架构每一层的意义
(1) nginx本地缓存：**抗的是热数据的高并发访问**，一般来说，商品的购买总是有热点的，比如每天购买iphone、nike、海尔等知名品牌的东西的人，总是比较多的

　　这些热数据，利用nginx本地缓存，由于经常被访问，所以可以被锁定在nginx的本地缓存内；大量的热数据的访问，就是经常会访问的那些数据，就会被保留在nginx本地缓存内，那么对这些热数据的大量访问，就直接走nginx就可以了，不需要走后续的各种网络开销了

(2) redis分布式大规模缓存：**抗的是很高的离散访问，访问量不高的数据**，支撑海量的数据，高并发的访问，高可用的服务，redis缓存拥有最大量的、最完整的数据和缓存。

　　**nginx本地内存有限，也就能缓存部分热数据，除了各种iphone、nike等热数据，其他相对不那么热的数据，可能流量会经常走到redis那里**。

　　利用redis cluster的多master写入，横向扩容，1T+以上海量数据支持，几十万的读写QPS，99.99%高可用性，那么就可以抗住大量的离散访问请求。

(3) tomcat jvm堆内存缓存：**主要是抗redis大规模灾难的**，如果redis出现了大规模的宕机，导致nginx大量流量直接涌入数据生产服务，那么最后的tomcat堆内存缓存至少可以再抗一下，不至于将大量的访问一下打到数据库上去，可能会直接导致数据库挂掉。

**tomcat jvm堆内存缓存，也可以抗住在redis没有查到的最后那少量的部分缓存数据**。

### 2.1 三层缓存架构读取数据顺序
- nginx+lua脚本做页面动态生成的工作，每次请求过来，**优先从nginx本地缓存中提取各种数据**，如果有数据返回，则结合页面模板生成需要的页面

- 如果nginx本地缓存过期了，那么就从nginx到redis中去拉取数据，更新到nginx本地

- 如果redis中也被LRU算法清理掉了或者没有所需数据，那么就从nginx走http接口到后端的服务中拉取数据，去本地tomcat里的jvm堆缓存中找；堆缓存ehcache如果也被LRU清理掉了，
那么就重新发送请求到源头的服务中去拉取数据，然后再次更新tomcat堆内存缓存+redis缓存，并返回数据给nginx，nginx缓存到本地

## 3.关于更新缓存的两种情形说明
(1) 时效性要求非常高的数据：比如商品库存

一般来说，显示的库存，都是时效性要求会相对高一些，因为随着商品的不断的交易，库存会不断的变化

对于这种数据，肯定希望当库存变化的时候，尽可能更快将库存显示到页面上去，而不是说等了很长时间，库存才反应到页面上去。

**对于时效性要求高的数据**，采取相关的服务系统每次发生了变更的时候，**直接采取数据库和redis缓存双写的方案，这样缓存的时效性最高**。

(2) 时效性要求不高的数据：商品的基本信息（名称、颜色、版本、规格参数，等等）

时效性要求不高的数据，就还好，比如说你现在改变了商品的名称，稍微晚个几分钟反应到商品页面上，也还能接受

商品基本信息等时效性不高的数据，而且种类繁多，来自多种不同的系统，**采取MQ异步通知的方式**，可以写一个数据生产服务，监听MQ消息，然后异步拉取服务的数据，更新tomcat jvm缓存+redis缓存

### 3.1 时效性高数据:数据库和redis缓存双写策略

　　**向redis缓存进行写的方式是通过删除缓存中的数据**，等下一次进行读请求时发现缓存中没有数据，则会去数据库中取出数据后并更新到redis中。
不论是先写数据库还是redis，都会因为并发出现读取时数据不一致的情况，如图所示：

![双写不一致情况](/src/main/images/redis/双写不一致情况.png)

　　针对上述问题，主要考虑更新操作和读操作等都需要遵循一定的顺序去执行，将数据库与缓存更新与读取操作进行异步串行化，
引入多个内存队列，每一个商品通过id计算hash加上对内存队列数量取模后路由到相应的内存队列；**当双写操作时，写数据库操作
还没有完成的时候，会根据唯一标识路由之后，发送到一个jvm内部的队列中；当来了一个读请求,如果发现数据不在缓存中，
那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，将发送到同一个jvm内部的队列中**，这样就会进行一个排队，不会出现数据不一致情况。

![复杂的数据库+缓存双写一致保障方案](/src/main/images/redis/复杂的数据库+缓存双写一致保障方案.png)

### 3.2 时效性低数据:消息队列MQ异步通知方案
　　该方案主要流程如下：
- 在写请求到达时，先进行写数据库操作
- 成功更新数据库后，将最新的数据发布到MQ消息队列中
- 一个特定服务一直监听队列，有数据则消费后将数据更新至ehcache和redis缓存中