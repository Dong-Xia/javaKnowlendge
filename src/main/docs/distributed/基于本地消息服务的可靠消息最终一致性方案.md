# 基于本地消息服务的可靠消息最终一致性方案
## 描述
　　如图所示为可靠消息服务最终一致性的完整处理流程，图中7个流程都可能发生异常，保证所有流程的可行性则能分布式事务的目标，
总结图中的流程为四种实现步骤：
![可靠消息流程](/src/main/images/可靠消息流程.jpg)
　　　　　　　　　　　　　　　　　　　　　　图1　可靠消息处理整体流程

    (1). 消息发送一致性的正向流程（可靠消息的前提保障）：生产者发送消息到消息队列的过程
    (2). 消息发送一致性的异常处理流程：生产者发送消息到消息队列的过程中出现的异常，如网络问题导致发送失败
    (3). 消息投递（消费）的正向流程：消息队列向消费者发送信息的消费过程
    (4). 消息投递（消费）的异常处理流程，需实现幂等：消息队列向消费者发送信息的消费过程出现的异常，如网络问题、消费过程处理异常等 
### 存在的问题
　　由于目前现成的消息中间件产品不支持图1消息发送一致的流程，具体为消息发送一致的流程实现是需先待提交后，等待确认成功2个步骤
后消息队列才会通知消费者进行消费；不可能去改造现有的消息中间件，这样成本太高，所以最佳解决方法为本地消息服务和独立消息服务的变通办法。
## 本地消息服务实现的思想
　　基于消息队列不能满足2步式流程的局限性，将信息待提交和确认步骤作为一个服务放置在本地，
并结合生产者生产信息服务一起，使用**本地事务实现数据一致性**。如图2所示。
![本地消息服务](/src/main/images/本地消息服务.jpg)
    　　　　　　　　　　　　　　　　　图２ 可靠消息最终一致性方案--本地消息服务
### 根据描述中4个步骤分析本地消息服务的可行性
1. 消息发送一致性的正向流程（可靠消息的前提保障）-- 实现思路
  
　　图2中消息发送和存储这样一套服务会耦合在每一个消息生产方服务中，并共用消息生产方服务的数据库。
具体实现会在数据库中建立一张消息记录表，用于记录消息的创建时间、消息内容、是否死亡、状态、重发次数等
信息，如下表１所示：
![本地消息业务表](/src/main/images/本地消息业务表.jpg)
　　　　　　　　　　　　　　　　　　　     表１ 本地消息表
2. 消息发送一致性的异常处理流程 -- 如何解决
 
　　图2中，业务操作和消息存储发送处于同一个事务中,具备ACID的特征，保证了要么都成功，要么都失败。
在相信消息队列处理消息是安全的情况下，图2中步骤1可能因为网络问题而导致MQ没有收到消息，这样会导致
主动方应用系统信息发送丢失了，影响后面的服务处理流程；**这里引入了消息恢复系统（采用定时机制，和本地消息表一样耦合在消息生产方服务中）**，它会根据本地信息表中消息发送的状态
和创建时间计算出发送未成功的超时消息后，进行重新发送，并记录重发次数，待下次重新发送时会先判断重发的次数是否超过设置的最大上限，
未超过才能继续重发，这样阻止了死循环的发生。
3. 消息投递（消费）的正向流程 -- 实现思路

　　这个步骤实现相对简单，和队列消费思想一致，只需正确实现消息的消费过程即可。
4. 消息投递（消费）的异常处理流程 -- 如何解决
    
    在消息消费中会因为网络原因、消费方处理消息出错等导致流程出现中断，从而MQ会因为没有收到消费方确认而重复发送消息给消费方,
    会导致消费方出现重复消费消息的情况出现，所以消费方必须实现消息的幂等性来应对这种异常情况的发生。
## 本地消息表实现方案的局限、弊端
1. 与具体的业务场景绑定，耦合性强，本地消息表不能共用
2. 消息数据和业务数据在同一个数据库，会占用业务服务的资源
3. 业务系统在使用关系型数据库的情况下，消息服务的性能会受到关系型数据库并发性能的影响


  
　　
