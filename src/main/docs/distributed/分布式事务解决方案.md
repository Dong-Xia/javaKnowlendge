# 分布式事务解决方案
<!-- MarkdownTOC -->
- [1. 事务介绍](#1-事务介绍)
    - [1.1 事务含义](#11-事务含义)
    - [1.2 事务四大特性ACID](#12-事务四大特性ACID)
    - [1.3 InnoDB实现原理(待完善)](#13-InnoDB实现原理(待完善))
- [2. 分布式事务](#2-分布式事务)
    - [2.1 分布式事务含义](#21-分布式事务含义)
    - [2.2 实现分布式事务的理论基础](#22-实现分布式事务的理论基础)
        - [2.2.1 CAP(需深入了解)](#221-CAP需深入了解)
        - [2.2.2 BASE(需深入了解)](#222-BASE需深入了解)
- [3. 分布式事务解决方案](#3-分布式事务解决方案)
    - [3.1 基于Base理论的分布式事务解决方案](#31-基于Base理论的分布式事务解决方案)
<!-- /MarkdownTOC -->
## 1. 事务介绍
### 1.1 事务含义
事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制。事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，所有操作都成功执行方能提交，否则整个事务的回滚。
### 1.2 事务四大特性ACID
- A：原子性(Atomicity)，一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。

        事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
        就像你买东西要么交钱收货一起都执行，要么发不出货，就退钱。
- C：一致性(Consistency)，事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。

        如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。
        如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。
- I：隔离性(Isolation)，指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。

        由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。
        事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。
        打个比方，你买东西这个事情，是不影响其他人的。
- D：持久性(Durability)，指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。

        即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。
        打个比方，你买东西的时候需要记录在账本上，即使老板忘记了那也有据可查。
### 1.3 InnoDB实现原理(待完善)
    事务的 ACID 是通过 InnoDB 日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，
    持久性通过 Redo Log（重做日志）来实现，原子性和一致性通过 Undo Log 来实现。

## 2. 分布式事务
### 2.1 分布式事务含义
分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
### 2.2 实现分布式事务的理论基础
我们之前说过数据库的 ACID 四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论。
#### 2.2.1 CAP需深入了解
CAP 定理，又被叫作布鲁尔定理
- C (一致性)：对某个指定的客户端来说，读操作能返回最新的写操作。
- A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。
- P (分区容错性)：当出现网络分区后，系统能够继续工作。打个比方，这里集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。
![分布式事务CAP定理图](/src/main/images/分布式事务CAP定理.jpg)
&ensp;&ensp;&ensp;&ensp;熟悉 CAP 的人都知道，三者不能共有，如果感兴趣可以搜索 CAP 的证明，在分布式系统中，网络无法 100% 可靠，分区其实是一个必然现象。
 
**&ensp;&ensp;&ensp;&ensp;如果我们选择了 CA 而放弃了 P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，
但是 A 又不允许，所以分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。**

&ensp;&ensp;&ensp;&ensp;对于 CP 来说，放弃可用性，追求一致性和分区容错性，我们的 ZooKeeper 其实就是追求的强一致。

&ensp;&ensp;&ensp;&ensp;对于 AP 来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的 BASE 也是根据 AP 来扩展。

&ensp;&ensp;&ensp;&ensp;顺便一提，**CAP 理论中是忽略网络延迟，也就是当事务提交时，从节点 A 复制到节点 B 没有延迟，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致**。

&ensp;&ensp;&ensp;&ensp;同时 CAP 中选择两个，比如你选择了 CP，并不是叫你放弃 A。因为 P 出现的概率实在是太小了，大部分的时间你仍然需要保证 CA。就算分区出现了你也要为后来的 A 做准备，比如通过一些日志的手段，是其他机器恢复至可用。
#### 2.2.2 BASE需深入了解
&ensp;&ensp;&ensp;&ensp;BASE 是 Basically Available(基本可用)、Soft state(柔性状态)和 Eventually consistent (最终一致性)三个短语的缩写，是对 CAP 中 AP 的一个扩展。
- 基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用（支持分区失败）。
- 柔性状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致（状态允许有短时间的不同步，异步）。
- 最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致（最终数据是一致的，但不是实时一致）。

&ensp;&ensp;&ensp;&ensp;**BASE 解决了 CAP 中理论没有网络延迟，在 BASE 中用柔性状态和最终一致，保证了延迟后的一致性。BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态**。

## 3. 分布式事务解决方案
&ensp;&ensp;&ensp;&ensp;是否真的要分布式事务在说方案之前，首先你一定要明确你是否真的需要分布式事务？

　　上面说过出现分布式事务的两个原因，其中有个原因是因为微服务过多。有些团队一个人维护几个微服务，过度设计，搞得所有人疲劳不堪。
**而微服务过多就会引出分布式事务，这个时候
### 3.1 基于Base理论的分布式事务解决方案
### 3.1.1 异步确保型方案（主要通过可靠消息最终一致性实现）
　　异步确保型方案主要适用于**业务不强调强一致性，允许在短时间内不一致，保证数据在最终达到一致，并且支持分区出现失败情况**，常用的解决方法是结合
消息队列中间件来实现。

　　如图所示为可靠消息服务最终一致性的完整处理流程，图中7个流程都可能发生异常，保证所有流程的可行性则能分布式事务的目标，
总结图中的流程为四种实现步骤：
![可靠消息流程](/src/main/images/可靠消息流程.jpg)
不建议去采用下面任何一种方案，而是请把需要事务的微服务聚合成一个单机服务，使用数据库的本地事务。**
因为不论任何一种方案都会增加系统的复杂度，这样的成本实在是太高了，千万不要因为追求某些设计，而引入不必要的成本和复杂度。
    
    (1). 消息发送一致性的正向流程（可靠消息的前提保障）：生产者发送消息到消息队列的过程
    
    (2). 消息发送一致性的异常处理流程：生产者发送消息到消息队列的过程中出现的异常，如网络问题导致发送失败
    
    (3). 消息投递（消费）的正向流程：消息队列向消费者发送信息的消费过程
    
    (4). 消息投递（消费）的异常处理流程，需要实现幂等：消息队列向消费者发送信息的消费过程出现的异常，如网络问题、消费过程处理异常等

　　常用的方案有以下三种，可根据不同的业务情况进行选择： 
   - [基于本地消息服务的可靠消息最终一致性方案](/src/main/docs/distributed/基于本地消息服务的可靠消息最终一致性方案.md)
   - [基于独立消息服务的可靠消息最终一致性方案](/src/main/docs/distributed/基于独立消息服务的可靠消息最终一致性方案.md)
   - 最大努力通知型方案
   
