# java 虚拟机运行时数据区
## 结构图
　　java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域有各自的用途，一些会随进程启动
而存在，一些会随线程的启动而创建，随结束而销毁。具体如图1所示。

![java运行时数据区域](/src/main/images/jvm/jvm运行时数据区.jpg)

### java堆
　　java堆是所有线程共享的区域，同时是占用内存最大的区域。它随虚拟机启动时创建，此区域存在的目的就是存放对象实例，所有的对象实例和数组都是在
堆区域进行内存分配。
　　java堆区域是java垃圾回收管理的主要区域，因此很多时候被称为“GC堆”，目前基本回收都采用分代收集算法，所以java堆细分为2个区域：

#### 1. 新生代
　　新生代分为三个区域空间：
   - eden空间
   - from survivor空间
   - to survivor空间
   
#### 2.老年代
   
### java方法区
　　方法区和java堆一样，属于所有线程的共享区域，主要用于存类信息、常量、静态变量等。虽然java虚拟机规范把方法区描述为
堆的一个逻辑区域，但是为了和java堆区别开来，所有有一个别名为“非堆”。

### java虚拟机栈
　　java虚拟机栈为线程私有，它的生命周期和线程一样，主要用于存储局部变量、操作数栈、动态链接、方法出口等，局部变量
表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用。

## 垃圾收集器
　　主要用于回收堆中不使用的对象信息，释放内存。对于怎么去确定一个对象是否具有被回收的条件，java垃圾回收提供了引用计数算法和
可达性分析算法来判断，目前主要采用可达性分析算法实现。
### 引用计数算法
　　**一个错误的描述说法**：给对象中添加一个引用计数器，每当一个地方引用它，则计数器就加1；当引用失效时，则计数器减1；任何
任何时刻引用计数器为0的对象则表示没有引用，可以回收。

　　**为什么说上面的描述是错误的呢？** 主流的java虚拟机都没有采用引用计数算法来管理内存，主要的原因是因为它很难
判断对象间相互循环引用的问题。比如objA和objB对象，都具有instance字段，赋值令objA.instance = objB
和objB.instance = objA , 除此之外，两个对象没有其他引用，实际上这两个对象已经不可能再被访问，但是因为它们互相
引用着对方，导致引用计数都不为0，于是就无法通知GC收集器回收它们。

### 可达性分析算法
　　java是通过可达性分析算法来判断对象是否存活的，可达性分析主要实现是通过一系列被称为“GC Roots”的对象作为起始点
，从这些节点开始向下搜索，所走过的一系列路径为“引用链”，判断一个对象到GC Roots没有任何引用链（也就是GC Roots到这个对象
不可达），则说明这个对象是可以被回收的。如图2所示：

![可达性分析算法](/src/main/images/jvm/可达性分析算法.jpg)

### 回收方法区
　　java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，主要是在方法区进行垃圾收集的性价比实在太低，方法区的永久代
的垃圾收集效率低，对永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

　　**无用的类，需满足三个条件，
    
    （1）该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
    （2）加载该类的ClassLoader已经被回收。
    （3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
　　满足上面条件可以进行回收，但是仅仅是“可以”，而并不是和堆中对象一样，不使用了就必然会回收。**

##  垃圾收集算法
### 分代收集算法 -- java虚拟机垃圾收集采用的算法
　　该算法主要思想是按照对象存活周期的不同采用最适合的垃圾回收算法进行回收；在新生代中，每次有大批对象死去，只有少量
对象存活，所以采用复制算法，只需要将少量存活对象进行复制就能完成收集，相对来说付出较少的成本；在老年代中，因为空间小，
没有额外的空间进行复制算法，且其中的对象存活率高，则只能采用“标记-清除算法”和“标记-整理算法”。
### 标记-清除算法
　　该算法分为两步：先标记出所有需要回收的对象，再标记完成后统一对标记对象进行回收。

    缺点：
    （１）效率不高：标记和清除两个过程效率都不高
    （２）碎片太多：进行标记和清除后产生大量不连续的空间碎片，导致来了一个大对象后，虚拟机堆没有足够的连续内存
    分配给这个对象，只能不得已去新触发一次垃圾回收动作，从而影响效率。
    
### 复制算法
　　该算法主要是针对“标记－清除算法”效率不高提出的，此算法的核心思想就是将内存容量分为两个等大的区域，将每次存活的
对象复制到另一块中，对使用过的内存空间一次性全部清理回收。
    
    缺点：虽然高效，但是代价是将内存缩小到了原来的一半，可用的内存太小了。
### 标记-整理算法
　　该算法吸取了前两种算法不高效、碎片太多和浪费50％空间的缺点，它将所有存活的对象都向一端移动，然后清理掉端边界以外的内存，
有效的防止了碎片的产生。

## 内存分配与回收策略
　　对象内存的分配，是在堆上分配，按照新对象主要分配到新生代中Eden区上，如果启动了本地线程分配缓冲，将按
线程优先在**TLAB上分配**，少数情况下也会直接分配到老年代中。
　　堆内存新生代和老年代结构图如下：

![堆内存结构.jpg](/src/main/images/jvm/堆内存结构.jpg)
### 对象优先在Eden分配
　　大多数情况下：新对象都在新生代Eden中分配，当Eden中没足够的内存去分配给对象时，虚拟机将会发起一次Minor GC。

    参数：
    -Xms20M、-Xmx20M、-Xmn10M 说明：-Xms和-Xmx限定了java堆分配的内存最大和最小值,当两个一样则表示允许扩展，
    如果最小设置为-Xms10M，最大设置为-Xmx30M，则每次用完最大内存30M后必须回收到10M，反复进行内存大小的调整比较影响性能。
    
### 大对象直接进入老年代
　　大对象是指需要大量的内存空间的java对象，典型的为很长的字符串和数组。大对象对于虚拟机来说是一个不好的消息，
当遇到一群“朝生夕灭”的“短命大对象”更是灾难，**经常出现大对象容易导致内存还有不少空间的前提下，由于无法满足大对象
的空间要求而必须提前触发垃圾回收以获取足够的连续空间来安放它们。** 所以在写程序时需尽量避免大对象。

    参数：
    -xx:PretenureSizeThreshold =3135728 : 设置一个值，当新对象所需内存空间大于该值，则直接进入老年代

### 长期存活的对象将进入老年代
　　虚拟机会给每个进入新生代的对象设定一个对象年龄计数器，每进行一次垃圾收集Minor GC后还存活的对象，年龄计数器则加１，
当达到设定的年代阈值则从新生代进入老年代。 新生代进入老年代流转过程如下图。
    
![新生代进入老年代的流程解析](/src/main/images/jvm/新生代进入老年代的流程解析.jpg)  

    参数：
    -XX:MaxTenuringThreshold = 15 : 设置进入老年代的阈值



    
   
